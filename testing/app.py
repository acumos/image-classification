# -*- coding: utf-8 -*-
# ================================================================================
# ACUMOS
# ================================================================================
# Copyright Â© 2017 AT&T Intellectual Property & Tech Mahindra. All rights reserved.
# ================================================================================
# This Acumos software file is distributed by AT&T and Tech Mahindra
# under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# This file is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ================================================================================
import connexion
import logging

import argparse
import json
import time

from flask import current_app, make_response
import pandas as pd
import numpy as np

from acumos.wrapped import load_model


def classify(mime_type, image_binary, rich_output=False):
    '''Consumes and produces protobuf binary data'''
    app = current_app
    time_start = time.clock()
    image_read = image_binary.stream.read()
    X = pd.DataFrame([['image/jpeg', image_read]], columns=['mime_type', 'image_binary'])
    method = app.model.classify
    # pred_raw = method.from_native(X).as_wrapped()   # alternate method once library is reevaluated

    type_in = method._input_type
    classify_in = type_in(*tuple(col for col in X.values.T))
    pred_raw = method.from_wrapped(classify_in).as_wrapped()

    pred = pd.DataFrame(np.column_stack(pred_raw), columns=pred_raw._fields)
    time_stop = time.clock()

    if rich_output:
        # NOTE: This response is specially formatted for the webdemo included with this package.
        #       Alternate forms of a response are viable for any other desired application.
        retObj = {
            'tags': [],
            'clientfile': 'undefined',
            'info': 'Processed',
            'processingtime': (time_stop - time_start),
            'serverfilename': '/dev/null',
            'status': 'Succeeded'
        }

        # iterate through predictions
        pred['rank'] = list(pred.index)
        pred['rank'] = pred['rank'] + 1
        retObj['tags'] = pred.to_dict(orient='records')

        # dump to pretty JSON
        retStr = json.dumps({'results': retObj}, indent=4)
    else:
        retStr = json.dumps(pred.to_dict(orient='records'), indent=4)

    # formulate response
    resp = make_response((retStr, 200, {}))
    # allow 'localhost' from 'file' or other;
    # NOTE: DO NOT USE IN PRODUCTION!!!
    resp.headers['Access-Control-Allow-Origin'] = '*'
    print(type(pred))
    print(retStr[:min(200, len(retStr))])
    # print(pred)
    return resp


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("--port", type=int, default=8885, help='port to launch the simple web server')
    parser.add_argument("--modeldir", type=str, default='../model', help='model dir to load dumped artifact')
    pargs = parser.parse_args()

    print("Configuring local application... {:}".format(__name__))
    logging.basicConfig(level=logging.INFO)
    app = connexion.App(__name__)
    app.add_api('swagger.yaml')
    # example usage:
    #     curl -F image_binary=@test.jpg -F mime_type="image/jpeg" "http://localhost:8885/transform"

    print("Loading model... {:}".format(pargs.modeldir))
    model = load_model(pargs.modeldir)  # refers to ./model dir in pwd. generated by helper script also in this dir
    app.app.model = model

    # run our standalone gevent server
    app.run(port=pargs.port)  # , server='gevent')
